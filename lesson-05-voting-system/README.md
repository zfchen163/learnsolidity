# 第5课：投票系统 🗳️

## 🎯 这一课你会学到

- 如何在合约中存储复杂数据（结构体、映射）
- 理解智能合约的状态管理
- 实现权限控制和防重复投票
- 使用 mapping 和 struct

## 🤔 人话解释

### 投票系统就像班级选班长

想象你们班要选班长：

```
候选人：小明、小红、小刚
规则：
1. 每人只能投一票
2. 不能给自己投票
3. 投票后不能改
4. 最后统计票数
```

**传统方式**（纸质投票）：
- 发纸条
- 写名字
- 投票箱
- 人工统计

**智能合约方式**（链上投票）：
- 每个地址只能投一次
- 自动记录和统计
- 公开透明
- 不可篡改

### 为什么用智能合约投票？

**优点**：
1. **透明**：所有人都能看到结果
2. **不可篡改**：投票后无法修改
3. **自动统计**：实时更新票数
4. **防作弊**：一人一票，无法重复

**缺点**：
1. 需要 Gas 费
2. 投票是公开的（可以看到谁投给谁）
3. 无法撤回

## 📝 合约设计

### 数据结构

```solidity
// 候选人结构体
struct Candidate {
    uint id;           // 编号
    string name;       // 名字
    uint voteCount;    // 得票数
}

// 投票人映射（记录谁投过票）
mapping(address => bool) public hasVoted;

// 投票选择（记录投给了谁）
mapping(address => uint) public votes;

// 候选人列表
Candidate[] public candidates;
```

### 核心功能

1. **添加候选人**（只有管理员）
2. **投票**（每人一次）
3. **查看结果**（实时统计）
4. **获胜者**（票数最多的）

## 💻 代码实现

我们会创建：
1. `Voting.sol` - 投票合约
2. `main.go` - Go 程序测试
3. `deploy.js` - 部署脚本

## 🚀 运行方式

```bash
cd lesson-05-voting-system
./run.sh
```

## 📊 预期输出

```
=== 🗳️ 投票系统测试 ===

1️⃣  部署投票合约
   ✅ 合约已部署: 0x5FbDB2...
   管理员: 0xf39Fd6...

2️⃣  添加候选人
   ✅ 添加候选人: 小明
   ✅ 添加候选人: 小红
   ✅ 添加候选人: 小刚
   
   候选人列表:
   [1] 小明 - 0 票
   [2] 小红 - 0 票
   [3] 小刚 - 0 票

3️⃣  开始投票
   👤 账户1 投票给: 小明
   ✅ 投票成功！
   
   👤 账户2 投票给: 小红
   ✅ 投票成功！
   
   👤 账户3 投票给: 小明
   ✅ 投票成功！
   
   👤 账户4 投票给: 小刚
   ✅ 投票成功！
   
   👤 账户5 投票给: 小明
   ✅ 投票成功！

4️⃣  实时统计
   [1] 小明 - 3 票 ███████████████
   [2] 小红 - 1 票 █████
   [3] 小刚 - 1 票 █████
   
   总投票数: 5

5️⃣  测试重复投票
   👤 账户1 尝试再次投票...
   ❌ 正确阻止：已经投过票了

6️⃣  测试无效候选人
   👤 账户6 投票给候选人99...
   ❌ 正确阻止：候选人不存在

7️⃣  宣布获胜者
   🏆 获胜者是: 小明
   得票数: 3 票
   得票率: 60%

=== ✅ 测试完成 ===
```

## 🔑 关键概念

### 1. Struct（结构体）

结构体用于组织相关数据：

```solidity
struct Candidate {
    uint id;
    string name;
    uint voteCount;
}

// 创建候选人
Candidate memory candidate = Candidate({
    id: 1,
    name: "小明",
    voteCount: 0
});
```

就像 Go 的 struct 或 Python 的 class。

### 2. Mapping（映射）

映射就像字典或哈希表：

```solidity
// 地址 → 布尔值
mapping(address => bool) public hasVoted;

// 使用
hasVoted[msg.sender] = true;
bool voted = hasVoted[msg.sender];
```

**特点**：
- 键值对存储
- 默认值（bool 默认 false，uint 默认 0）
- 无法遍历所有键
- Gas 效率高

### 3. Array（数组）

动态数组可以存储多个元素：

```solidity
Candidate[] public candidates;

// 添加元素
candidates.push(candidate);

// 访问元素
Candidate memory c = candidates[0];

// 获取长度
uint count = candidates.length;
```

### 4. Modifier（修饰符）

修饰符用于复用权限检查：

```solidity
modifier onlyOwner() {
    require(msg.sender == owner, "只有管理员");
    _;  // 继续执行函数
}

function addCandidate(string memory name) public onlyOwner {
    // 只有 owner 能调用
}
```

## 🎮 动手试试

运行代码后，试试这些：

1. **添加更多候选人**：试试5个、10个候选人
2. **模拟大规模投票**：让100个账户投票
3. **添加功能**：
   - 投票截止时间
   - 最低投票数要求
   - 投票权重（VIP 可以投2票）
4. **改进安全性**：
   - 防止管理员作弊
   - 匿名投票

## ❓ 常见问题

**Q: 投票是匿名的吗？**
A: 不是！区块链上所有交易都是公开的。可以看到哪个地址投给了谁。要实现匿名投票需要用零知识证明等高级技术。

**Q: 可以撤回投票吗？**
A: 在我们的简单版本中不行。但可以添加这个功能，让投票者在截止前修改。

**Q: 如何防止女巫攻击（一人多账户）？**
A: 
- 简单版本：无法防止
- 进阶方案：
  - 要求质押代币
  - 使用身份验证（KYC）
  - 基于信誉的投票权重

**Q: Gas 费谁出？**
A: 投票者自己出。这可能限制参与度。解决方案：
- 项目方补贴 Gas
- 使用 Layer 2（Gas 更便宜）
- 批量投票

**Q: 如何保证公平？**
A: 
- 代码开源，所有人都能审计
- 投票规则写在合约里，无法修改
- 结果自动统计，无人工干预

## 💡 实际应用

### 1. DAO 治理

去中心化组织用投票决策：

```
提案：是否升级合约？
投票期：7天
要求：超过50%赞成票
```

### 2. 社区决策

NFT 项目用投票选择：

```
- 下一个作品主题
- 资金使用方向
- 合作伙伴选择
```

### 3. 链上问卷

收集社区意见：

```
- 产品功能优先级
- 活动时间安排
- Logo 设计选择
```

## 🎯 下一课预告

现在你理解了状态管理！下一课我们会学习：
- **简单的代币（ERC20）**
- 什么是代币标准
- 如何创建自己的代币
- 转账、授权、查询余额

---

💡 **记住**：智能合约的状态就像数据库，mapping 是哈希表，struct 是结构体！
